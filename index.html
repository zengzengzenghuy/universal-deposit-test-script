<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Universal Deposit Demo</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f5f5f5;
      }
      .container {
        background: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
      }
      .wallet-section {
        background: #e3f2fd;
        border: 2px solid #2196f3;
      }
      .inputs-section {
        background: #f3e5f5;
        border: 2px solid #9c27b0;
      }
      .logs-section {
        background: #e8f5e8;
        border: 2px solid #4caf50;
        max-height: 400px;
        overflow-y: auto;
      }
      input,
      select {
        width: 100%;
        padding: 10px;
        margin: 5px 0;
        border: 1px solid #ddd;
        border-radius: 5px;
        box-sizing: border-box;
      }
      button {
        background: #2196f3;
        color: white;
        padding: 12px 24px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin: 5px;
      }
      button:hover {
        background: #1976d2;
      }
      button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      .step {
        border: 1px solid #ddd;
        padding: 15px;
        margin: 10px 0;
        border-radius: 5px;
        background: #fafafa;
      }
      .step.active {
        border-color: #2196f3;
        background: #e3f2fd;
      }
      .step.completed {
        border-color: #4caf50;
        background: #e8f5e8;
      }
      .log-entry {
        padding: 5px 0;
        border-bottom: 1px solid #eee;
        font-family: monospace;
        font-size: 14px;
      }
      .log-entry:last-child {
        border-bottom: none;
      }
      .chain-info {
        font-size: 12px;
        color: #666;
        margin-top: 5px;
      }
      .error {
        color: #f44336;
        background: #ffebee;
        padding: 10px;
        border-radius: 5px;
        margin: 10px 0;
      }
      .success {
        color: #4caf50;
        background: #e8f5e8;
        padding: 10px;
        border-radius: 5px;
        margin: 10px 0;
      }
      .grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
      }
    </style>
  </head>
  <body>
    <h1>üåâ Universal Deposit Demo</h1>

    <!-- Wallet Connection Section -->
    <div class="container wallet-section">
      <h2>üíº Wallet Connection (Required First)</h2>
      <button id="connectWallet">Connect MetaMask Wallet</button>
      <div id="walletInfo" style="margin-top: 10px"></div>

      <!-- API Key Section - only visible after wallet connection -->
      <div
        id="apiKeySection"
        style="
          display: none;
          margin-top: 20px;
          padding-top: 20px;
          border-top: 1px solid #ddd;
        ">
        <label for="apiKey">API Key:</label>
        <input
          type="password"
          id="apiKey"
          placeholder="Enter your API key..."
          style="margin-bottom: 5px" />
        <small style="display: block; color: #666"
          >This API key will be used for bridge API calls</small
        >
      </div>
    </div>

    <!-- Input Section -->
    <div class="container inputs-section">
      <h2>‚öôÔ∏è Configuration</h2>

      <div class="grid">
        <div>
          <label>Owner Address:</label>
          <input type="text" id="ownerAddress" placeholder="0x..." disabled />
          <small>Address with permission to withdraw unsupported tokens</small>
        </div>

        <div>
          <label>Recipient Address:</label>
          <input
            type="text"
            id="recipientAddress"
            placeholder="0x..."
            disabled />
          <small>Address to receive tokens on destination chain</small>
        </div>
      </div>

      <div class="grid">
        <div>
          <label>Source Chain:</label>
          <select id="sourceChain" disabled>
            <!-- Options will be populated from config.json -->
          </select>
          <div class="chain-info" id="sourceChainInfo">
            <!-- Chain info will be populated dynamically -->
          </div>
        </div>

        <div>
          <label>Destination Chain:</label>
          <select id="dstChain" disabled>
            <!-- Options will be populated from config.json -->
          </select>
          <div class="chain-info" id="dstChainInfo">
            <!-- Chain info will be populated dynamically -->
          </div>
        </div>
      </div>

      <div>
        <label>USDC Amount:</label>
        <input
          type="number"
          id="usdcValue"
          value="2000000"
          placeholder="2000000"
          disabled />
        <small>2,000,000 = 2 USDC (6 decimal places)</small>
      </div>

      <button id="startBridge" disabled>Start Bridge Process</button>
    </div>

    <!-- Steps Section -->
    <div class="container">
      <h2>üìã Bridge Steps</h2>

      <div class="step" id="step1">
        <h3>Step 1: Register Address & Get Universal Address</h3>
        <p>
          Register address for monitoring and get the Universal Deposit address
        </p>
        <div id="step1Result"></div>
      </div>

      <div class="step" id="step2">
        <h3>Step 2: Query Nonce</h3>
        <p>
          Get the current nonce of the Universal Deposit address (starts from 0)
        </p>
        <div id="step2Result"></div>
      </div>

      <div class="step" id="step3">
        <h3>Step 3: Bridge USDC</h3>
        <p>Transfer USDC to the Universal Deposit address</p>
        <div id="step3Result"></div>
      </div>

      <div class="step" id="step4">
        <h3>Step 4: Poll for Completion</h3>
        <p>Monitor order status until COMPLETED (up to 5 minutes)</p>
        <div id="step4Result"></div>
      </div>
    </div>

    <!-- Logs Section -->
    <div class="container logs-section">
      <h2>üìù Real-time Logs</h2>
      <div id="logs"></div>
      <button onclick="clearLogs()">Clear Logs</button>
    </div>

    <script>
      let walletConnected = false;
      let currentAccount = null;
      let currentStep = 0;
      let apiKey = null;

      // Load chain configurations from config.json
      let chainConfigs = {};
      let configData = null;

      // Load config.json
      async function loadConfig() {
        try {
          const response = await fetch("./config.json");
          configData = await response.json();

          // Build chain configs from config.json
          chainConfigs = {};
          configData.chains.forEach((chain) => {
            chainConfigs[chain.chainId] = {
              name: chain.name,
              usdc: chain.contracts.usdc,
              stargateUsdc: chain.contracts.stargateUsdc,
            };
          });

          // Populate chain selects
          populateChainSelects();
        } catch (error) {
          console.error("Failed to load config.json:", error);
          // Fallback to hardcoded configs
          chainConfigs = {
            41923: {
              name: "Edu Chain",
              usdc: "0x12a272A581feE5577A5dFa371afEB4b2F3a8C2F8",
              stargateUsdc: "0x28BEc7E30E6faee657a03e19Bf1128AaD7632A00",
            },
            100: {
              name: "Gnosis Chain",
              usdc: "0x2a22f9c3b484c3629090FeED35F17Ff8F88f76F0",
              stargateUsdc: "0xB1EeAD6959cb5bB9B20417d6689922523B2B86C3",
            },
            42161: {
              name: "Arbitrum",
              usdc: "0xaf88d065e77c8cc2239327c5edb3a432268e5831",
              stargateUsdc: "0xe8CDF27AcD73a434D661C84887215F7598e7d0d3",
            },
          };
        }
      }

      // Update chain info when selection changes
      document
        .getElementById("sourceChain")
        .addEventListener("change", function () {
          updateDestinationChains();
          updateChainInfo();
        });

      document
        .getElementById("dstChain")
        .addEventListener("change", function () {
          updateChainInfo();
        });

      // Chain mapping for routing rules
      function getChainKey(chainId, chainName) {
        const name = chainName.toLowerCase().replace(/\s+/g, "");
        if (name.includes("edu")) return "edu";
        if (name.includes("gnosis")) return "gnosis";
        if (name.includes("arbitrum")) return "arbitrum";
        if (name.includes("base")) return "base";
        if (name.includes("ethereum") && !name.includes("arbitrum"))
          return "ethereum";
        if (name.includes("optimism")) return "optimism";
        return null;
      }

      function populateChainSelects() {
        const sourceSelect = document.getElementById("sourceChain");
        const dstSelect = document.getElementById("dstChain");

        // Clear existing options
        sourceSelect.innerHTML = "";
        dstSelect.innerHTML = "";

        // Define supported chains
        const supportedChains = [
          "arbitrum",
          "educhain",
          "ethereum",
          "base",
          "optimism",
          "gnosis",
        ];

        // Filter chains to only show supported ones
        const filteredChains = Object.entries(chainConfigs).filter(
          ([chainId, config]) => {
            const chainKey = getChainKey(chainId, config.name);
            return chainKey !== null;
          }
        );

        // Populate source chain select with all supported chains
        filteredChains.forEach(([chainId, config]) => {
          const sourceOption = new Option(
            `${config.name} (${chainId})`,
            chainId
          );
          sourceSelect.add(sourceOption);
        });

        // Set default source selection if available
        if (chainConfigs[41923]) sourceSelect.value = "41923"; // Edu Chain

        // Update destination chains based on initial source selection
        updateDestinationChains();
        updateChainInfo();
      }

      function updateDestinationChains() {
        const sourceChainId = document.getElementById("sourceChain").value;
        const dstSelect = document.getElementById("dstChain");
        const currentDstValue = dstSelect.value;

        // Clear destination options
        dstSelect.innerHTML = "";

        if (!sourceChainId || !chainConfigs[sourceChainId]) return;

        const sourceChainKey = getChainKey(
          sourceChainId,
          chainConfigs[sourceChainId].name
        );

        // Define routing rules
        let allowedDestinations = [];

        if (sourceChainKey === "gnosis") {
          // Gnosis can go to: EDU, Arbitrum, Base, Ethereum, Optimism
          allowedDestinations = [
            "edu",
            "arbitrum",
            "base",
            "ethereum",
            "optimism",
          ];
        } else if (
          ["edu", "arbitrum", "base", "ethereum", "optimism"].includes(
            sourceChainKey
          )
        ) {
          // These chains can only go to Gnosis
          allowedDestinations = ["gnosis"];
        }

        // Populate destination select based on allowed destinations
        Object.entries(chainConfigs).forEach(([chainId, config]) => {
          const chainKey = getChainKey(chainId, config.name);
          if (allowedDestinations.includes(chainKey)) {
            const option = new Option(`${config.name} (${chainId})`, chainId);
            dstSelect.add(option);
          }
        });

        // Try to preserve previous selection if still valid
        if (
          currentDstValue &&
          Array.from(dstSelect.options).some(
            (option) => option.value === currentDstValue
          )
        ) {
          dstSelect.value = currentDstValue;
        } else if (dstSelect.options.length > 0) {
          // Set default destination based on source
          if (sourceChainKey === "gnosis") {
            // Default to EDU if available
            const eduOption = Array.from(dstSelect.options).find(
              (option) =>
                getChainKey(option.value, chainConfigs[option.value]?.name) ===
                "edu"
            );
            if (eduOption) dstSelect.value = eduOption.value;
          } else {
            // Default to Gnosis
            const gnosisOption = Array.from(dstSelect.options).find(
              (option) =>
                getChainKey(option.value, chainConfigs[option.value]?.name) ===
                "gnosis"
            );
            if (gnosisOption) dstSelect.value = gnosisOption.value;
          }
        }
      }

      function updateChainInfo() {
        const sourceChain = document.getElementById("sourceChain").value;
        const dstChain = document.getElementById("dstChain").value;

        if (chainConfigs[sourceChain]) {
          document.getElementById(
            "sourceChainInfo"
          ).innerHTML = `USDC: ${chainConfigs[sourceChain].usdc}<br>Stargate USDC: ${chainConfigs[sourceChain].stargateUsdc}`;
        }

        if (chainConfigs[dstChain]) {
          document.getElementById(
            "dstChainInfo"
          ).innerHTML = `USDC: ${chainConfigs[dstChain].usdc}<br>Stargate USDC: ${chainConfigs[dstChain].stargateUsdc}`;
        }
      }

      // Override console.log to capture logs
      const originalLog = console.log;
      console.log = function (...args) {
        originalLog.apply(console, args);
        addLog(args.join(" "));
      };

      function addLog(message) {
        const logsDiv = document.getElementById("logs");
        const logEntry = document.createElement("div");
        logEntry.className = "log-entry";
        logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        logsDiv.appendChild(logEntry);
        logsDiv.scrollTop = logsDiv.scrollHeight;
      }

      function clearLogs() {
        document.getElementById("logs").innerHTML = "";
      }

      function setStepActive(stepNum) {
        // Remove active class from all steps
        document.querySelectorAll(".step").forEach((step) => {
          step.classList.remove("active");
        });
        // Add active class to current step
        if (stepNum > 0) {
          document.getElementById(`step${stepNum}`).classList.add("active");
        }
      }

      function setStepCompleted(stepNum) {
        const step = document.getElementById(`step${stepNum}`);
        step.classList.remove("active");
        step.classList.add("completed");
      }

      function showError(message) {
        const errorDiv = document.createElement("div");
        errorDiv.className = "error";
        errorDiv.textContent = message;
        document.body.insertBefore(
          errorDiv,
          document.querySelector(".container")
        );
        setTimeout(() => errorDiv.remove(), 5000);
      }

      function showSuccess(message) {
        const successDiv = document.createElement("div");
        successDiv.className = "success";
        successDiv.textContent = message;
        document.body.insertBefore(
          successDiv,
          document.querySelector(".container")
        );
        setTimeout(() => successDiv.remove(), 5000);
      }

      // Wallet connection
      document
        .getElementById("connectWallet")
        .addEventListener("click", async () => {
          if (typeof window.ethereum !== "undefined") {
            try {
              const accounts = await window.ethereum.request({
                method: "eth_requestAccounts",
              });
              currentAccount = accounts[0];
              walletConnected = true;

              document.getElementById("walletInfo").innerHTML = `
                        <div class="success">‚úÖ Connected: ${currentAccount}</div>
                    `;

              // Show API key section
              document.getElementById("apiKeySection").style.display = "block";

              // Enable inputs
              document.getElementById("ownerAddress").value = currentAccount;
              document.getElementById("recipientAddress").value =
                currentAccount;

              const inputs = [
                "ownerAddress",
                "recipientAddress",
                "sourceChain",
                "dstChain",
                "usdcValue",
              ];
              inputs.forEach((id) => {
                document.getElementById(id).disabled = false;
              });
              document.getElementById("startBridge").disabled = false;

              console.log("Wallet connected:", currentAccount);
              showSuccess("Wallet connected successfully!");
            } catch (error) {
              console.error("Failed to connect wallet:", error);
              showError("Failed to connect wallet: " + error.message);
            }
          } else {
            showError(
              "MetaMask is not installed. Please install MetaMask to continue."
            );
          }
        });

      // Start bridge process
      document
        .getElementById("startBridge")
        .addEventListener("click", async () => {
          if (!walletConnected) {
            showError("Please connect your wallet first");
            return;
          }

          // Get and validate API key
          apiKey = document.getElementById("apiKey").value.trim();
          if (!apiKey) {
            showError("Please enter your API key");
            return;
          }

          try {
            await executeBridgeProcess();
          } catch (error) {
            console.error("Bridge process failed:", error);
            showError("Bridge process failed: " + error.message);
          }
        });

      async function executeBridgeProcess() {
        const ownerAddress = document.getElementById("ownerAddress").value;
        const recipientAddress =
          document.getElementById("recipientAddress").value;
        const sourceChainId = parseInt(
          document.getElementById("sourceChain").value
        );
        const dstChainId = parseInt(document.getElementById("dstChain").value);
        const usdcValue = parseInt(document.getElementById("usdcValue").value);

        console.log("Starting bridge process...");
        console.log(
          `Using API Key: ${"*".repeat(Math.min(apiKey.length, 8))}...`
        );
        console.log(
          `From: ${chainConfigs[sourceChainId].name} (${sourceChainId})`
        );
        console.log(`To: ${chainConfigs[dstChainId].name} (${dstChainId})`);
        console.log(`Amount: ${usdcValue} USDC (${usdcValue / 1000000} USDC)`);

        // Check if user is on the correct source chain
        try {
          const currentChainId = await window.ethereum.request({
            method: 'eth_chainId'
          });
          const currentChainIdDecimal = parseInt(currentChainId, 16);
          
          if (currentChainIdDecimal !== sourceChainId) {
            console.log(`Current chain: ${currentChainIdDecimal}, Required: ${sourceChainId}`);
            
            // Try to switch to the source chain
            try {
              await window.ethereum.request({
                method: 'wallet_switchEthereumChain',
                params: [{ chainId: `0x${sourceChainId.toString(16)}` }],
              });
              console.log(`Switched to chain ${sourceChainId}`);
            } catch (switchError) {
              throw new Error(`Please switch to ${chainConfigs[sourceChainId].name} (Chain ID: ${sourceChainId}) in your wallet to continue.`);
            }
          }
        } catch (error) {
          showError(`Chain validation failed: ${error.message}`);
          return;
        }

        // Step 1: Register Address
        setStepActive(1);
        console.log(
          "Step 1: Registering address and getting Universal Address..."
        );

        let universalAddress;
        try {
          const registerResponse = await fetch(
            "https://prod.universal-deposit.gnosischain.com/api/v1/register-address",
            {
              method: "POST",
              headers: {
                accept: "application/json",
                "X-API-Key": apiKey,
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                ownerAddress,
                recipientAddress,
                destinationChainId: dstChainId,
                sourceChainId: sourceChainId,
              }),
            }
          );

          if (!registerResponse.ok) {
            throw new Error(
              `Registration failed: ${registerResponse.statusText}`
            );
          }

          const registerData = await registerResponse.json();
          universalAddress = registerData.universalAddress;
          console.log("UD address", universalAddress);

          document.getElementById("step1Result").innerHTML = `
                  <div class="success">‚úÖ Universal Address: ${universalAddress}</div>
              `;
          setStepCompleted(1);
        } catch (error) {
          document.getElementById("step1Result").innerHTML = `
                  <div class="error">‚ùå Failed to register address: ${error.message}</div>
              `;
          throw error;
        }

        // Step 2: Query Nonce
        setStepActive(2);
        console.log("Step 2: Querying UD address nonce...");

        let UDAddressNonce;
        try {
          // Call the nonce view function on the contract on the source chain
          const nonceData = await window.ethereum.request({
            method: "eth_call",
            params: [
              {
                to: universalAddress,
                data: "0xaffed0e0", // nonce() function selector
              },
              "latest",
              `0x${sourceChainId.toString(16)}` // Ensure we're querying the correct chain
            ],
          });

          // If contract doesn't exist, nonce is 0
          UDAddressNonce = nonceData === "0x" ? 0 : parseInt(nonceData, 16);
          console.log(`Nonce: ${UDAddressNonce}`);

          document.getElementById("step2Result").innerHTML = `
                  <div class="success">‚úÖ Nonce: ${UDAddressNonce}</div>
              `;
          setStepCompleted(2);
        } catch (error) {
          console.log("Contract may not exist yet, using nonce 0");
          UDAddressNonce = 0;
          document.getElementById("step2Result").innerHTML = `
                  <div class="success">‚úÖ Nonce: ${UDAddressNonce} (new contract)</div>
              `;
          setStepCompleted(2);
        }

        // Step 3: Bridge USDC
        setStepActive(3);
        console.log("Step 3: Bridging USDC...");

        let bridgeUSDCTxHash;
        try {
          // Get USDC contract address for source chain
          const usdcAddress = chainConfigs[sourceChainId].usdc;

          // ERC20 transfer function selector and data
          const transferData =
            "0xa9059cbb" + // transfer(address,uint256) selector
            universalAddress.slice(2).padStart(64, "0") + // to address (32 bytes)
            usdcValue.toString(16).padStart(64, "0"); // value (32 bytes)

          // Send transaction via MetaMask
          bridgeUSDCTxHash = await window.ethereum.request({
            method: "eth_sendTransaction",
            params: [
              {
                from: currentAccount,
                to: usdcAddress,
                data: transferData,
                gas: "0x15f90", // 90000 gas limit for ERC20 transfer
                chainId: `0x${sourceChainId.toString(16)}`, // Ensure transaction is on correct chain
              },
            ],
          });

          console.log("Bridge USDC Tx hash", bridgeUSDCTxHash);

          document.getElementById("step3Result").innerHTML = `
                  <div class="success">‚úÖ Transaction Hash: ${bridgeUSDCTxHash}</div>
              `;
          setStepCompleted(3);
        } catch (error) {
          document.getElementById("step3Result").innerHTML = `
                  <div class="error">‚ùå Failed to bridge USDC: ${error.message}</div>
              `;
          throw error;
        }

        // Step 4: Poll for completion
        setStepActive(4);
        console.log("Step 4: Polling for order status...");

        const maxAttempts = 30;
        const delayMs = 2000;
        let attempt = 0;
        let orderCompleted = false;
        let orderResult = null;

        while (attempt < maxAttempts && !orderCompleted) {
          attempt++;

          await simulateDelay(delayMs);

          try {
            const ordersResponse = await fetch(
              `https://prod.universal-deposit.gnosischain.com/api/v1/orders?universalAddress=${universalAddress}&sourceChainId=${sourceChainId}&nonce=${UDAddressNonce}&limit=10`,
              {
                headers: {
                  accept: "application/json",
                  "X-API-Key": apiKey,
                },
              }
            );

            if (ordersResponse.ok) {
              orderResult = await ordersResponse.json();
              console.log(
                `Attempt ${attempt}: Order status - ${orderResult.status}`
              );

              if (orderResult.status === "COMPLETED") {
                orderCompleted = true;
                const bridgeTransactionUrl =
                  orderResult.bridgeTransactionUrl ||
                  `https://layerzeroscan.com/tx/${bridgeUSDCTxHash}`;
                console.log("Order completed successfully!");
                console.log("Transaction URL:", bridgeTransactionUrl);

                document.getElementById("step4Result").innerHTML = `
                            <div class="success">
                                ‚úÖ Order completed successfully!<br>
                                <a href="${bridgeTransactionUrl}" target="_blank">View Transaction</a>
                            </div>
                        `;
                setStepCompleted(4);
                showSuccess("üéâ Bridge completed successfully!");
                break;
              } else {
                document.getElementById("step4Result").innerHTML = `
                            <div>‚è≥ Attempt ${attempt}/${maxAttempts}: ${
                  orderResult.status || "PENDING"
                }</div>
                        `;
              }
            } else {
              console.log(`Attempt ${attempt}: Order not found yet`);
              document.getElementById("step4Result").innerHTML = `
                          <div>‚è≥ Attempt ${attempt}/${maxAttempts}: Order not found yet</div>
                      `;
            }
          } catch (error) {
            console.log(
              `Attempt ${attempt}: Error fetching order - ${error.message}`
            );
            document.getElementById("step4Result").innerHTML = `
                        <div>‚è≥ Attempt ${attempt}/${maxAttempts}: Checking...</div>
                    `;
          }

          if (attempt < maxAttempts && !orderCompleted) {
            console.log(
              `Waiting ${delayMs / 1000} seconds before next check...`
            );
          }
        }

        if (!orderCompleted) {
          throw new Error("Order did not complete within the expected time");
        }

        console.log("Bridge process completed successfully!");
      }

      function simulateDelay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      // Initialize
      loadConfig();
    </script>
  </body>
</html>
